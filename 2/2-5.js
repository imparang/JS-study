//! Immutable
// memory
// [1, 2, 3, 4, 5, 6]
// [ | | | | | ]
let a = "xy";

// ['xy'| | | | | ]
console.log(a); // a가 가지고 있는 주소(1번 주소)에 있는 데이터를 출력

let b = a; // a, b 모두 같은 메모리 주소(1번 주소)를 가리킴
console.log(a, b); // 'xy', 'xy'

// 원시형 데이터는 Immutable
// 123은 2번 주소로 감
// ['xy'|123| | | | ]
b = 123; // b는 2번 주소를 가리킴.
console.log(b); // b가 가지고 있는 주소(2번 주소)에 있는 데이터를 출력

// -------
// memory
// [1, 2, 3, 4, 5, 6]
// [{x:}|1|{x:}| | | ]
// 1번(c, d)과 3번(h)의 x는 2번 주소에 있는 원시형 데이터 1을 가리킴

let c = { x: 1 };
let d = c; // c, d 모두 같은 메모리 주소(1번 주소)를 가리킴

// [{x:7}| | | | | ]
d.x = 7; // 메모리 주소만 옮겨지고 실제 안의 데이터는 변함 => mutable
console.log(c); // {x:7}
let h = { x: 1 };
h.x = 8;
// [{x:}|1|{x:}|8| | ]
// h가 가리키는 메모리 주소(3번)의 x는 4번 주소에 있는 원시형 데이터 8을 가리킴

//---------

// 참조형 데이터는 mutable 하므로: c === d => true, c === h => false, d === h => false
// 생성될 때마다 메모리에 새롭게 생성

// --------
// memory
// [1, 2, 3, 4, 5, 6]
// ['1'| | | | | ] 한 곳만 가리킴
let e = "1";
let f = e;
let g = "1";
// 원시형 데이터는 Immutable 하므로: e === g => true, e === f => true, f === g => true

/// -------
// memory
// [1, 2, 3, 4, 5, 6]
// [ | | | | | ]

// [{x:1}|{x:1, y:2}| | | | ]
// ? 전개 연산자는 같은 참조데이터를 가리키는 것이 아님. 일반적으로는
let q = { x: 1 };
let w = {
  ...q,
  y: 2
};

// ? 하지만 깊은 구조로 들어가면 같은 참조 데이터를 가리킨다.
// memory
// [1, 2, 3, 4, 5, 6]
// [ | | | | | ]

// [{x:}|{y:1}|{x:}| | | ]
// {x:}(1번주소) 가 {y:1}(2번주소)을 가리킴
let z = {
  x: {
    y: 1
  }
};

// {x:}(3번주소) 가 {y:1}(2번주소)을 가리킴
let x = {
  ...z
};

x.x.y = 8;

// [{x:}|{y:8}|{x:}| | | ]
console.log(z.x.y); // 8

// * 그래서 shallow copy라고 함.

// ---------
// memory
// [1, 2, 3, 4, 5, 6]
// [ | | | | | ]

// ['x'| | | | | ]
let aa = "x";
let bb = aa;

// ['x'|7| | | | ]
aa = 7;

// ['x'|7|0| | | ]
bb = 0;
// 'x'을 가리키는 것이 없지만, 바로 삭제되지는 않는다.
// 가비지 컬렉션이 해결해줌. 하지만 명확한 시점은 알 수 없다.
// [ |7|0| | | ]

// 안쓰는 것이 존재할 경우 => 불필요한 데이터가 메모리에 존재한다는 의미
// 이것이 안좋은 코드를 만듬
// 안쓰면 지워라!!!

// ---------
// memory
// [1, 2, 3, 4, 5, 6]
// [ | | | | | ]

// [[@,@,@,@]|1|'2'|null| | ]  ->  배열은 인덱스가 데이터의 주소를 가리킨다.
let aaa = [1, "2", null, {}];
